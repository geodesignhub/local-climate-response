{% extends "layout.html" %}
{% block headercss %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/maplibre/maplibre-gl.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/common.css') }}">

{% endblock %}
{% block body %}
<div class="container">
    <!-- Example row of columns -->
    {% if op['status'] == 1 %}
    <br>
    <div class="row">
        <div class="col-md-12">
            <div>
                <h6>{{ gettext('Project Theme details') }}</h6>
                <ul class="list-group list-group-horizontal">
                    {% for system in op.project_data.system_details %}
                        <li class="list-group-item"><b>{{ system.name }}&nbsp;<i class="bi bi-info-square-fill" style="color: {{system.color}}" data-bs-toggle="tooltip" data-bs-placement="bottom" title="{{system.verbose_description}}"></i></b></li>
                    {% endfor %}
                </ul>
            </div>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-12">
            <div id="spinner" class="spinner-border text-secondary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h3>{{ gettext('Shadow Analysis') }}</h3>
            <p class="text-muted">{{ gettext('By default the shadow is computed for August 6 at 10AM when radiation is not strong') }}
            </p>
            <br>
            <div id="map"></div>
        </div>
    </div>
    <br>
    <!-- <div class="row">
        <div class="col-md-12">
            <div>
                <label for="shadow_date_time">{{ gettext('Select new (date and time)') }}:</label>
                <input type="datetime-local" id="shadow_date_time" name="shadow_date_time">
                <input type="submit" value="Update Shadows" onclick="return update_date_time();" />
            </div>
        </div>
    </div> -->
    <br>

    <div class="row">
        <div class="col-md-12">
            <div id="listing-group" class="btn-group" role="group" aria-label="Layer selection tools">
                {% for wms_layer in op['wms_layers'] %}
                <input type="checkbox" class="btn-check" id="{{wms_layer['dom_id']}}" autocomplete="off" checked>
                <label class="btn btn-outline-primary" for="{{wms_layer['dom_id']}}">{{ wms_layer['name']}}</label>
                {% endfor %}

                {% for cog_layer in op['cog_layers'] %}
                <input type="checkbox" class="btn-check" id="{{cog_layer['dom_id']}}" autocomplete="off" checked>
                <label class="btn btn-outline-primary" for="{{cog_layer['dom_id']}}">{{ cog_layer['name']}}</label>
                {% endfor %}
                {% for fgb_layer in op['fgb_layers'] %}
                <input type="checkbox" class="btn-check" id="{{fgb_layer['dom_id']}}" autocomplete="off" checked>
                <label class="btn btn-outline-primary" for="{{fgb_layer['dom_id']}}">{{ fgb_layer['name']}}</label>
                {% endfor %}
                {% for pmtiles_layer in op['pmtiles_layers'] %}
                <input type="checkbox" class="btn-check" id="{{pmtiles_layer['dom_id']}}" autocomplete="off" checked>
                <label class="btn btn-outline-primary" for="{{pmtiles_layer['dom_id']}}">{{
                    pmtiles_layer['name']}}</label>
                {% endfor %}
            </div>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-12">
            <h6>{{ gettext('Design Shadow') }}&nbsp;<small class="text-muted">{{ gettext('Area of the shadow generated by buildings') }}</small></h6>
        </div>
        
    </div>
    <div class="row">
        <div class="col-md-8">
            <h4>
                <span id='building_shadows'></span>
                <small class="text-muted">{{ gettext('in hectares') }}</small>
            </h4>
        </div>
    </div>
    <br>
    <div class="row">
        <div class="col-md-12">
            <h6>{{ gettext('Design Shadow Analysis') }}</h6>
        </div>
    </div>
    <div id="shadow_stats" class="row d-none">
        <div class="col-md-6">
            <h4>
                <span id='total_roads'></span>
                <small class="text-muted">{{ gettext('Total Roads (meters)') }}</small>
            </h4>
        </div>
        <div class="col-md-6">
            <h4>
                <span id='shadowed_roads'></span>
                <small class="text-muted">{{ gettext('Shadowed Roads (meters)') }}</small>
            </h4>

        </div>
    </div>
    <br>
    {% else %}
    <div class="row">
        <div class="col-md-12">
            <p>{{op['message']}}</p>
        </div>
    </div>
    {% endif %}
    <br>
    <br>
</div>
<!-- /container -->
{% endblock %}

{% block footer %}

{% if op['status'] == 1 %}
<script type="text/javascript" src="{{ url_for('static', filename='js/maplibre/maplibre-gl.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/common.js') }}"></script>
<script src="{{ url_for('static', filename='js/threejs/three.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/threejs/GLTFLoader.js') }}"></script>

{% if op['cog_layers'] %}
<script type="text/javascript" src="{{ url_for('static', filename='js/cog/cog-protocol.min.js') }}"></script>
{% endif %}
{% if op['fgb_layers'] %}
<script type="text/javascript" src="{{ url_for('static', filename='js/fgb/flatgeobuf-geojson.min.js') }}"></script>
{% endif %}

<script type="text/javascript" src="{{ url_for('static', filename='js/pmtiles/pmtiles.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='js/pmtiles/working_theme.js') }}"></script>


<script type="text/javascript">
    let tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    let tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl)
    })
    const design_detail = {{ op|safe}};

    const design_geojson = {{ op["geometry_data"]["geojson"]|safe }};
    const trees_geojson = {{ op["trees_feature_collection"]["geojson"]|safe }};
    const bounds = design_detail['project_data']['bounds']['bounds'];
    const session_id = design_detail['session_id']
    var latLngs = bounds.split(',');
    var southWest = new maplibregl.LngLat(latLngs[0], latLngs[1]);
    var northEast = new maplibregl.LngLat(latLngs[2], latLngs[3]);
    var map_bounds = new maplibregl.LngLatBounds(southWest, northEast);
    let wms_layers = design_detail['wms_layers'];
    let cog_layers = design_detail['cog_layers'];
    let fgb_layers = design_detail['fgb_layers'];
    let pmtiles_layers = design_detail['pmtiles_layers'];
    
    let pmtiles_protocol = new pmtiles.Protocol({ metadata: true });
    maplibregl.addProtocol("pmtiles", pmtiles_protocol.tile);

    // let pmtiles_style = protomaps_themes_base.default("protomaps","light");

    // let building_style = pmtiles_style.find(style_item => style_item.id === 'buildings'); 
    // console.log(building_style);
    // let filtered_styles = light_theme.filter(x => {
    //     return x.id != 'buildings';
    // })
    // filtered_styles.push(building_style_item);
    const PMTILES_URL = 'https://gdh-tiles.ams3.digitaloceanspaces.com/osm2025.pmtiles';

    const p = new pmtiles.PMTiles(PMTILES_URL);

    // this is so we share one instance across the JS code and the map renderer
    pmtiles_protocol.add(p);

    const map = new maplibregl.Map({
    container: 'map', // container id  
    bounds: map_bounds,
    zoom:10,
        style: {

            glyphs:'https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf',
            sprite: "https://protomaps.github.io/basemaps-assets/sprites/v4/light",
            version: 8,
            sources: {
                'protomaps': {
                    type: 'vector',
                    url: `pmtiles://${PMTILES_URL}`,
                    attribution: 'Â© <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>'
                }
            },
            layers: light_theme
        }
    });

    
    if (cog_layers.length > 0) {
        maplibregl.addProtocol('cog', MaplibreCOGProtocol.cogProtocol);
    }

    
    document.getElementById('listing-group').addEventListener('change', function (e) {
        var map_layer = e.target.id;
        let map_layer_line_id = map_layer + "_lines";
        let map_layer_point_id = map_layer + "_points";

        let all_ids = [map_layer, map_layer_line_id, map_layer_point_id];

        for (let index = 0; index < all_ids.length; index++) {
            const map_source_id = all_ids[index];
            if (map.getLayer(map_source_id)) {
                if (e.target.checked) {
                    map.setLayoutProperty(map_source_id, 'visibility', 'visible');
                } else {
                    map.setLayoutProperty(map_source_id, 'visibility', 'none');
                }
            }
        }
    });
    // function update_date_time() {
    //     let new_url = new URL(window.location.href);

    //     let date_time = new_url.searchParams.delete('date_time');

    //     const dateControl = document.querySelector('input[type="datetime-local"]');
    //     let new_date = dateControl.value;
    //     if (new_date) {
    //         new_url.searchParams.append('date_time', new_date);
    //         window.location.href = new_url;
    //     }
    //     return true;
    // }


    map.on('load', async () => {
        map.addSource('buildings', {
            // GeoJSON Data source used in vector tiles, documented at
            // https://gist.github.com/ryanbaumann/a7d970386ce59d11c16278b90dde094d
            'type': 'geojson',
            'data': design_geojson
        });
        map.addSource('building_shadows', {
            // GeoJSON Data source used in vector tiles, documented at
            // https://gist.github.com/ryanbaumann/a7d970386ce59d11c16278b90dde094d
            'type': 'geojson',
            'data': { "type": "FeatureCollection", "features": [] }
        });
        map.addSource('existing_building_shadows', {
            // GeoJSON Data source used in vector tiles, documented at
            // https://gist.github.com/ryanbaumann/a7d970386ce59d11c16278b90dde094d
            'type': 'geojson',
            'data': { "type": "FeatureCollection", "features": [] }
        });
        
        map.addSource('bike_pedestrian_roads', {
            // GeoJSON Data source used in vector tiles, documented at
            // https://gist.github.com/ryanbaumann/a7d970386ce59d11c16278b90dde094d
            'type': 'geojson',
            'data': { "type": "FeatureCollection", "features": [] }
        });
        
        map.addLayer({
            'id': 'buildings-extrusion',
            'type': 'fill-extrusion',
            'source': 'buildings',
            'paint': {
                // See the MapLibre Style Specification for details on data expressions.
                // https://maplibre.org/maplibre-gl-js-docs/style-spec/expressions/

                // Get the fill-extrusion-color from the source 'color' property.
                'fill-extrusion-color': ['get', 'color'],

                // Get fill-extrusion-height from the source 'height' property.
                'fill-extrusion-height': ['get', 'height'],

                // Get fill-extrusion-base from the source 'base_height' property.
                'fill-extrusion-base': ['get', 'base_height'],

                // Make extrusions slightly opaque for see through indoor walls.
                'fill-extrusion-opacity': 0.5
            }
        });
        map.addLayer({
            'id': 'building_shadows',
            'type': 'fill',
            'source': 'building_shadows',
            'layout': {},
            'paint': {
                'fill-color': '#808080',
                'fill-opacity': 0.7
            }
        });
        map.addLayer({
            'id': 'existing_building_shadows',
            'type': 'fill',
            'source': 'existing_building_shadows',
            'layout': {},
            'paint': {
                'fill-color': '#a9a9a9',
                'fill-opacity': 0.4
            }
        });
        map.addLayer({
            'id': 'bike_pedestrian_roads',
            'type': 'line',
            'source': 'bike_pedestrian_roads',
            'layout': {
                'line-join': 'round',
                'line-cap': 'round'
            },
            'paint': {
                'line-color': '#422518',
                'line-width': 3,
                'line-opacity': 0.4
            }
        });
        map.addControl(
            new maplibregl.NavigationControl({
                visualizePitch: true,
                showZoom: true,
                showCompass: true
            })
        );
        for (let index = 0; index < wms_layers.length; index++) {
            const wms_layer = wms_layers[index];
            let source_str = wms_layer.dom_id + "_source";
            map.addSource(source_str, {
                'type': 'raster',
                // use the tiles option to specify a WMS tile source URL
                // https://maplibre.org/maplibre-style-spec/sources/
                'tiles': [wms_layer['url']],
                'tileSize': 256
            });
            map.addLayer(
                {
                    'id': wms_layer['dom_id'],
                    'type': 'raster',
                    'source': source_str,
                    'paint': {}
                },
                'aeroway_fill'
            );

        }

        if (cog_layers.length > 0) {
            for (let index = 0; index < cog_layers.length; index++) {
                const cog_layer = cog_layers[index];

                let source_str = cog_layer.dom_id + "_source";
                map.addSource(source_str, {
                    'type': 'raster',
                    'url': 'cog://' + cog_layer['url'],
                    'tileSize': 256
                });
                map.addLayer(
                    {
                        'id': cog_layer['dom_id'],
                        'source': source_str,
                        'type': 'raster',
                        'paint': {}
                    },
                    'aeroway_fill'
                );
            }
        }
        if (pmtiles_layers.length > 0) {
            for (let index = 0; index < pmtiles_layers.length; index++) {
                const pmtiles_layer = pmtiles_layers[index];
                console.log(pmtiles_layer);
                let source_str = pmtiles_layer.dom_id + "_source";
                if (pmtiles_layer.layer_type == 'raster') {
                    map.addSource(source_str, {
                        'type': 'raster',
                        'url': 'pmtiles://' + pmtiles_layer['url']
                    });
                    map.addLayer(
                        {
                            'id': pmtiles_layer['dom_id'],
                            'source': source_str,
                            'type': 'raster',
                            'paint': {}
                        },
                        'aeroway_fill'
                    );
                }
            }
        }


        if (fgb_layers.length > 0) {
            for (let index = 0; index < fgb_layers.length; index++) {
                const fgb_layer = fgb_layers[index];
                const geometry_type = fgb_layer['geometry_type'];
                const response = await fetch(fgb_layer['url']);
                let source_str = fgb_layer.dom_id + "_source";
                const fc = { type: "FeatureCollection", features: [] };
                let i = 0;
                for await (const f of flatgeobuf.deserialize(response.body, undefined)) {
                    fc.features.push({ ...f, id: i });
                    i += 1;
                }

                map.addSource(source_str, {
                    type: "geojson",
                    data: fc,
                });
                if (geometry_type == 'polygon') {
                    map.addLayer({
                        id: fgb_layer['dom_id'],
                        type: "fill",
                        source: source_str,
                        paint: {
                            "fill-color": fgb_layer['color'],
                            "fill-opacity": 0.75,
                        },
                    });
                }
                else if (geometry_type == 'line') {
                    map.addLayer({
                        id: fgb_layer['dom_id'] + "_lines",
                        type: "line",
                        source: source_str,
                        paint: {
                            "line-color": fgb_layer['color'],
                            "line-opacity": 0.9,
                            "line-width": 2,
                        },
                    });
                }

                else if (geometry_type == 'point') {
                    map.addLayer({
                        id: fgb_layer['dom_id'] + "_points",
                        type: 'circle',
                        source: source_str,
                        paint: {

                            "circle-blur": 0,
                            "circle-color": fgb_layer['color'],
                            "circle-opacity": 0.8,
                            "circle-radius": 10,
                            "circle-stroke-color": fgb_layer['color'],
                            "circle-stroke-opacity": 0.9,
                            "circle-stroke-width": 1,

                        }

                    });
                }
            }
        }
    });

    async function process_trees() {
            /*
            * Helper function used to get threejs-scene-coordinates from mercator coordinates.
            * This is just a quick and dirty solution - it won't work if points are far away from each other
            * because a meter near the north-pole covers more mercator-units
            * than a meter near the equator.
            */
                
            const results = await Promise.all([loadModel()]);
            const model = results[0];
            
            function calculateDistanceMercatorToMeters(from, to) {
                const mercatorPerMeter = from.meterInMercatorCoordinateUnits();
                // mercator x: 0=west, 1=east
                const dEast = to.x - from.x;
                const dEastMeter = dEast / mercatorPerMeter;
                // mercator y: 0=north, 1=south
                const dNorth = from.y - to.y;
                const dNorthMeter = dNorth / mercatorPerMeter;
                return {dEastMeter, dNorthMeter};
            }

            
            async function loadModel() {
                const loader = new THREE.GLTFLoader();
                const gltf = await loader.loadAsync(
                "{{ url_for('static', filename='assets/low_poly_tree.glb') }}");
                const model = gltf.scene;
                return model;
            }
            const project_center = design_detail['project_data']['center']['center'].split(',');            
            const sceneOrigin = new maplibregl.LngLat(parseFloat(project_center[0]), parseFloat(project_center[1]));
            
            const sceneOriginMercator = maplibregl.MercatorCoordinate.fromLngLat(sceneOrigin);
            const three_d_tree_layer = {
                id: '3d-model',
                type: 'custom',
                renderingMode: '3d',
                onAdd(map, gl) {
                    this.camera = new THREE.Camera();
                    this.scene = new THREE.Scene();
                    this.scene.rotateX(Math.PI / 2);
                    this.scene.scale.multiply(new THREE.Vector3(1, 1, -1));
                    const light = new THREE.DirectionalLight(0xffffff);
                    light.position.set(50, 70, -30).normalize();
                    this.scene.add(light);

                    for (var x = 0; x < trees_geojson.features.length; x++){
                        const curmodel = model.clone();
                        const tree_coordinates = trees_geojson.features[x].geometry.coordinates;
                        const tree_location = new maplibregl.LngLat(parseFloat(tree_coordinates[0]),parseFloat(tree_coordinates[1]));
                        const model_mercator = maplibregl.MercatorCoordinate.fromLngLat(tree_location);
                        const {dEastMeter: model1east, dNorthMeter: model1north} = calculateDistanceMercatorToMeters(sceneOriginMercator, model_mercator);
                        curmodel.position.set(model1east-8.75, 0, model1north+0.75);
                        this.scene.add(curmodel);
                    }
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: map.getCanvas(),
                        context: gl,
                        antialias: true
                    });
                    this.renderer.autoClear = false;
                },

                render(gl, mercatorMatrix) {

                    const offsetFromCenterElevation = map.queryTerrainElevation(sceneOrigin) || 0;
                    const sceneOriginMercator = maplibregl.MercatorCoordinate.fromLngLat(sceneOrigin, offsetFromCenterElevation);

                    const sceneTransform = {
                        translateX: sceneOriginMercator.x,
                        translateY: sceneOriginMercator.y,
                        translateZ: sceneOriginMercator.z,
                        scale: sceneOriginMercator.meterInMercatorCoordinateUnits()
                    };

                    const m = new THREE.Matrix4().fromArray(mercatorMatrix);
                    const l = new THREE.Matrix4()
                        .makeTranslation(sceneTransform.translateX, sceneTransform.translateY, sceneTransform.translateZ)
                        .scale(new THREE.Vector3(sceneTransform.scale, -sceneTransform.scale, sceneTransform.scale));

                    this.camera.projectionMatrix = m.multiply(l);
                    this.renderer.resetState();
                    this.renderer.render(this.scene, this.camera);
                    map.triggerRepaint();
                }
            };
            map.addLayer(three_d_tree_layer);
        }
    
    document.addEventListener('DOMContentLoaded', () => {
        const room = design_detail.session_id;
        var source = new EventSource("{{ url_for('sse.stream') }}");
        source.addEventListener('gdh_shadow_generation_success', function (event) {
            var data = JSON.parse(event.data);
            // do what you want with this data
            let shadow_id_key = data['shadow_key'];
            let session_id = shadow_id_key.split(':')[0]
            if (session_id === room) {
                // The message is for the current sesion, download the data...
                let shadow_download_url = window.location.origin + '/gdh_generated_shadow?shadow_key=' + shadow_id_key;
                get_building_shadow(shadow_download_url);
            }
        }, false);
        source.addEventListener('existing_buildings_shadow_generation_success', function (event) {
            var data = JSON.parse(event.data);
            // do what you want with this data
            let shadow_id_key = data['shadow_key'];
            let session_id = shadow_id_key.split(':')[0]
            if (session_id === room) {
                // The message is for the current sesion, download the data...
                let shadow_download_url = window.location.origin + '/existing_buildings_generated_shadow?shadow_key=' + shadow_id_key;
                get_existing_building_shadow(shadow_download_url);
            }
        }, false);

        source.addEventListener('roads_download_success', function (event) {
            var data = JSON.parse(event.data);
            // do what you want with this data
            let roads_key = data['roads_key'];
            let session_id = roads_key.split(':')[0]
            if (session_id === room) {
                // The message is for the current sesion, download the data...
                let roads_download_url = window.location.origin + '/get_downloaded_roads?roads_key=' + roads_key;
                get_downloaded_roads(roads_download_url);
            }
        }, false);
        source.addEventListener('roads_shadow_complete', function (event) {
            var data = JSON.parse(event.data);
            // do what you want with this data
            let roads_shadow_stats_key = data['roads_shadow_stats_key'];
            let session_id = roads_shadow_stats_key.split(':')[0]
            if (session_id === room) {
                // The message is for the current sesion, download the data...
                let roads_shadow_stats_url = window.location.origin + '/get_shadow_roads_stats?roads_shadow_stats_key=' + roads_shadow_stats_key;
                get_road_shadow_stats(roads_shadow_stats_url);
            }
        }, false);
        process_trees();

    });
</script>
{% endif %}

{% endblock %}